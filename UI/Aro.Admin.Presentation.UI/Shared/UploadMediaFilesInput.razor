@using Aro.UI.Application.DTOs
@inject IJSRuntime JSRuntime

<div id="mediaContainer" class="row gap-3 media-container w-100 rounded border border-1 p-3">
    @foreach (var image in Images)
    {
        <div class="col-sm-2 h-100 rounded d-flex align-items-center justify-content-center p-1 position-relative border uploaded-image
                                @(draggedImageId == image.Id ? "dragging" : "") @(draggedAboveImageId == image.Id ? "dragged-above" : "")"
             @key="image.Id"
             draggable="true"
             @ondragstart="() => HandleDragStart(image)"
             @ondragend="HandleDragEnd"
             @ondragover="() => HandleDragAbove(image)"
             @ondragover:preventDefault
             @ondrop="() => HandleDrop(image)"
             @ondrop:preventDefault
             @onclick="() => SelectImage(image)">

            <MudIconButton Icon="@Icons.Material.Filled.Close"
                           class="remove-btn"
                           Variant="Variant.Filled"
                           Size="Size.Small"
                           @onclick="@(e => RemoveImage(image))" />

            <img src="data:image/png;base64,@image.ContentBase64"
                 alt="@image.Name"
                 class="img-fluid rounded"
                 style="max-height: 100%; object-fit: cover;" />

            @* <span class="index">@image.OrderIndex</span> *@
        </div>
    }

    @if (Images.Count < MaxImages)
    {
        <button class="col-sm-2 add-box h-100 rounded d-flex align-items-center justify-content-center p-0">
            <MudFileUpload T="IReadOnlyList<IBrowserFile>"
                           FilesChanged="UploadFiles"
                           Accept="image/png,image/jpeg"
                           MaxFiles="@RemainingSlots"
                           Class="w-100">
                <ActivatorContent>
                    <div class="vstack text-center w-100 h-100">
                        <span>+</span>
                        <span>Add</span>
                        <span>@RemainingSlots Left</span>
                    </div>
                </ActivatorContent>
            </MudFileUpload>
        </button>
    }
</div>

@if (HasError)
{
    @foreach (var msg in ErrorMessages)
    {
        <span class="small text-danger">@msg</span>
        <br />
    }
}

<style>
    .add-box {
        background-color: #EBEBEB;
        border: dashed 1px #929292;
    }

    .media-container {
        height: 200px;
        border-color: #929292;
    }

    .remove-btn {
        position: absolute;
        top: 5px;
        right: 5px;
        z-index: 10;
    }

    .index {
        position: absolute;
        bottom: 5px;
        right: 5px;
        z-index: 10;
    }

    .uploaded-image:hover {
        box-shadow: 0px 8px 24px 4px rgba(0, 0, 0, 0.12);
    }

    .uploaded-image:active {
        cursor: grabbing;
    }

    .uploaded-image.dragging {
        opacity: 0.5;
        transform: scale(0.98);
    }

    .uploaded-image.dragged-above {
        border: 2px dashed #F69126 !important;
        background: #FFF5EB;
    }
</style>

@code {
    [Parameter] public List<ImageModel> Images { get; set; } = new();
    [Parameter] public EventCallback<List<ImageModel>> ImagesChanged { get; set; }
    [Parameter] public EventCallback<ImageModel?> SelectedImageChanged { get; set; }

    private const int MaxImages = 5;
    private const long MaxAllowedFileBytes = 2 * 1024 * 1024;

    private int RemainingSlots => MaxImages - Images.Count;

    private bool HasError;
    private List<string> ErrorMessages = new();

    private static readonly string[] AllowedContentTypes = { "image/jpeg", "image/png" };

    private Guid? draggedImageId;
    private Guid? draggedAboveImageId;
    private ImageModel? draggedImage;

    private async Task UploadFiles(IReadOnlyList<IBrowserFile> files)
    {
        ErrorMessages.Clear();
        HasError = false;

        foreach (var file in files)
        {
            if (!AllowedContentTypes.Contains(file.ContentType))
            {
                ErrorMessages.Add($"{file.Name} has an invalid file type.");
                HasError = true;
                continue;
            }

            if (file.Size > MaxAllowedFileBytes)
            {
                ErrorMessages.Add($"{file.Name} exceeds 2MB.");
                HasError = true;
                continue;
            }

            using var ms = new MemoryStream();
            await file.OpenReadStream(MaxAllowedFileBytes).CopyToAsync(ms);

            Images.Add(new ImageModel
            {
                Id = Guid.NewGuid(),
                Name = Path.GetFileNameWithoutExtension(file.Name),
                ContentBase64 = Convert.ToBase64String(ms.ToArray()),
                OrderIndex = Images.Count + 1,
                IsThumbnail = Images.Count == 0
            });
        }

        await ImagesChanged.InvokeAsync(Images);
    }

    private async Task RemoveImage(ImageModel image)
    {
        Images.Remove(image);
        await ImagesChanged.InvokeAsync(Images);
        await SelectedImageChanged.InvokeAsync(null);
    }

    private async Task SelectImage(ImageModel image)
    {
        await SelectedImageChanged.InvokeAsync(image);
    }

    private void HandleDragStart(ImageModel image)
    {
        draggedImage = image;
        draggedImageId = image.Id;
    }

    private void HandleDragEnd()
    {
        draggedImage = null;
        draggedImageId = null;
        draggedAboveImageId = null;
    }

    private void HandleDragAbove(ImageModel image)
    {
        if (draggedImageId != null && draggedImageId != image.Id)
        {
            draggedAboveImageId = image.Id;
        }
    }

    private async Task HandleDrop(ImageModel target)
    {
        if (draggedImage == null || draggedImage.Id == target.Id)
        {
            HandleDragEnd();
            return;
        }

        var from = Images.IndexOf(draggedImage);
        var to = Images.IndexOf(target);

        Images.RemoveAt(from);
        Images.Insert(to, draggedImage);

        Images[from].OrderIndex = from + 1;
        Images[to].OrderIndex = to + 1;

        HandleDragEnd();
        await ImagesChanged.InvokeAsync(Images);
    }
}
